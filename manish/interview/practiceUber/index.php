<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
<title>Untitled Document</title>
<style type="text/css">
<!--
body {
	font-family: Verdana, Arial, Helvetica, sans-serif;
	font-size: 11px;
}
-->
</style>
</head>

<body>
<h1>Problems</h1>
<table width="100%" border="1" cellspacing="0" cellpadding="5">
    <tr>
        <td valign="top"><strong>Easy</strong></td>
        <td valign="top"><strong>Companies</strong></td>
        <td valign="top"><strong>Medium</strong></td>
        <td valign="top"><strong>Companies</strong></td>
        <td valign="top"><strong>Hard</strong></td>
        <td valign="top"><strong>Companies</strong></td>
    </tr>
    <tr>
        <td valign="top"><a href="#two_sum">1. Two Sum</a></td>
        <td valign="top">Uber, </td>
        <td valign="top">17 Letter Combinations of a Phone Number</td>
        <td valign="top">Uber, </td>
        <td valign="top">10 Regular Expression Matching</td>
        <td valign="top">Uber, </td>
    </tr>
    <tr>
        <td valign="top">8 String to Integer (atoi)</td>
        <td valign="top">Uber, </td>
        <td valign="top">22 Generate Parentheses</td>
        <td valign="top">Uber, </td>
        <td valign="top">23 Merge k Sorted Lists</td>
        <td valign="top">Uber, </td>
    </tr>
    <tr>
        <td valign="top">13 Roman to Integer</td>
        <td valign="top">Uber, </td>
        <td valign="top">39 Combination Sum</td>
        <td valign="top">Uber, </td>
        <td valign="top">24 Swap Nodes in Pairs</td>
        <td valign="top">Uber, </td>
    </tr>
    <tr>
        <td valign="top">36 Valid Sudoku</td>
        <td valign="top">Uber, </td>
        <td valign="top">49 Group Anagrams</td>
        <td valign="top">Uber, </td>
        <td valign="top">33 Search in Rotated Sorted Array</td>
        <td valign="top">Uber, </td>
    </tr>
    <tr>
        <td valign="top">104 Maximum Depth of Binary Tree</td>
        <td valign="top">Uber, </td>
        <td valign="top">54 Spiral Matrix</td>
        <td valign="top">Uber, </td>
        <td valign="top">37 Sudoku Solver</td>
        <td valign="top">Uber, </td>
    </tr>
    <tr>
        <td valign="top">121 Best Time to Buy and Sell Stock</td>
        <td valign="top">Uber, </td>
        <td valign="top">78 Subsets</td>
        <td valign="top">Uber, </td>
        <td valign="top">76 Minimum Window Substring</td>
        <td valign="top">Uber, </td>
    </tr>
    <tr>
        <td valign="top">125 Valid Palindrome</td>
        <td valign="top">Uber, </td>
        <td valign="top">91 Decode Ways</td>
        <td valign="top">Uber, </td>
        <td valign="top">138 Copy List with Random Pointer</td>
        <td valign="top">Uber, </td>
    </tr>
    <tr>
        <td valign="top">155 Min Stack</td>
        <td valign="top">Uber, </td>
        <td valign="top">133 Clone Graph</td>
        <td valign="top">Uber, </td>
        <td valign="top">140 Word Break</td>
        <td valign="top">Uber, </td>
    </tr>
    <tr>
        <td valign="top">171 Excel Sheet Column Number</td>
        <td valign="top">Uber, </td>
        <td valign="top">139 Word Break</td>
        <td valign="top">Uber, </td>
        <td valign="top">146 LRU Cache</td>
        <td valign="top">Uber, </td>
    </tr>
    <tr>
        <td valign="top">202 Happy Number</td>
        <td valign="top">Uber, </td>
        <td valign="top">161 One Edit Distance</td>
        <td valign="top">Uber, </td>
        <td valign="top">262 Trips and Users</td>
        <td valign="top">Uber, </td>
    </tr>
    <tr>
        <td valign="top">206 Reverse Linked List</td>
        <td valign="top">Uber, </td>
        <td valign="top">186 Reverse Words in a String II</td>
        <td valign="top">Uber, </td>
        <td valign="top">291 Word Pattern II</td>
        <td valign="top">Uber, </td>
    </tr>
    <tr>
        <td valign="top">242 Valid Anagram</td>
        <td valign="top">Uber, </td>
        <td valign="top">208 Implement Trie (Prefix Tree)</td>
        <td valign="top">Uber, </td>
        <td valign="top">297 Serialize and Deserialize Binary Tree</td>
        <td valign="top">Uber, </td>
    </tr>
    <tr>
        <td valign="top">249 Group Shifted Strings</td>
        <td valign="top">Uber, </td>
        <td valign="top">230 Kth Smallest Element in a BST</td>
        <td valign="top">Uber, </td>
        <td valign="top">&nbsp;</td>
        <td valign="top">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top">266 Palindrome Permutation</td>
        <td valign="top">Uber, </td>
        <td valign="top">254 Factor Combinations</td>
        <td valign="top">Uber, </td>
        <td valign="top">&nbsp;</td>
        <td valign="top">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top">290 Word Pattern</td>
        <td valign="top">Uber, </td>
        <td valign="top">337 House Robber III</td>
        <td valign="top">Uber, </td>
        <td valign="top">&nbsp;</td>
        <td valign="top">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top">&nbsp;</td>
        <td valign="top">&nbsp;</td>
        <td valign="top">&nbsp;</td>
        <td valign="top">&nbsp;</td>
        <td valign="top">&nbsp;</td>
        <td valign="top">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top"><a href="#jsclosureaddquestion">Javascript Closure Questions</a></td>
        <td valign="top">&nbsp;</td>
        <td valign="top">&nbsp;</td>
        <td valign="top">&nbsp;</td>
        <td valign="top">&nbsp;</td>
        <td valign="top">&nbsp;</td>
    </tr>
</table>

<div>
<h3>1. Two Sum</h3>
<a name="two_sum"></a>
<pre>
// Given an array of integers, return indices of the two numbers such that they add up to a specific target.

// You may assume that each input would have exactly one solution.

// Example:
// Given nums = [2, 7, 11, 15], target = 9,

// Because nums[0] + nums[1] = 2 + 7 = 9,
// return [0, 1].
// UPDATE (2016/2/13):
// The return format had been changed to zero-based indices. Please read the above updated description carefully.

// Hide Company Tags LinkedIn Uber Airbnb Facebook Amazon Microsoft Apple Yahoo Dropbox Bloomberg Yelp Adobe
// Hide Tags Array Hash Table
// Hide Similar Problems (M) 3Sum (M) 4Sum (M) Two Sum II - Input array is sorted (E) Two Sum III - Data structure design



/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function(nums, target) {
    var hash = {};
    
    for(var i = 0; i < nums.length; i++) {
        var num = nums[i];
        if(hash[num] !== undefined) {
            return [hash[num], i]
        } else {
            hash[target - num] = i;
        }
    }
    
    return [];
};
</pre>

<hr />
</div>

<div>
<h3>8 String to Integer (atoi)</h3>
<a name="atoi"></a>
<pre>
// Implement atoi to convert a string to an integer.

// Hint: Carefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the possible input cases.

// Notes: It is intended for this problem to be specified vaguely (ie, no given input specs). You are responsible to gather all the input requirements up front.
/**
 * @param {string} str
 * @return {number}
 */
var myAtoi = function(str) {
    var num = 0;
    var baseCharCode = '0'.charCodeAt(0);
    var sign = 1;
    
    str = str.trim();
    
    if(str[0] === '+' || str[0] === '-') {
        
        if(str[0] === '-') {
            sign = -1;
        }
        
        str = str.substring(1);
    }
    
    for(var i = 0; i < str.length; i++) {
        var c = str[i];
        var charCode = c.charCodeAt(0) - baseCharCode;
        
        if(0 <= charCode && charCode <= 9) {
            num *= 10;
            num += charCode;
        } else {
            break;
        }
    }
    
    var maxInt = Math.pow(2,31) - 1;
    var minNegInt = -Math.pow(2,31);
    
    num = sign*num;
    
    if(0 < num && maxInt < num) {
        return maxInt;
    }
    
    if(num < 0 && num < minNegInt) {
        return minNegInt;
    }
    
    return num;
};
</pre>
<hr />
</div>




<div>
<h3>10 Regular Expresion Matching</h3>
<a name=""></a>
<pre>
<?php 
echo $x = file_get_contents('../leetcode-javascript-master/10 Regular Expresion Matching.js');
?>
</pre>
<hr />
</div>


<div>
<h3>13. Roman To Integer</h3>
<a name="romanToInt"></a>
<pre>
/**
 * @param {string} s
 * @return {number}
 */
var romanToInt = function(s) {
    var result = 0;
    
    for(var i = 0; i < s.length; i++){
        if(i > 0 && (c2n(s[i]) > c2n(s[i-1]))){
            result -= 2*c2n(s[i-1]); // because previously added [!!!]
        }
        
        result += c2n(s[i]);
    }
    
    return result;
};

var c2n = function(c){
    switch(c){
        case 'I': return 1;
        case 'V': return 5;
        case 'X': return 10;
        case 'L': return 50;
        case 'C': return 100;
        case 'D': return 500;
        case 'M': return 1000;
        default: return 0;
    }
}


</pre>
<hr />
</div>


<div>
<h3>36 Valid Sudoku</h3>
<a name="isValidSudoku"></a>
<pre>
/**
 * @param {character[][]} board
 * @return {boolean}
 */
var isValidSudoku = function(board) {
    // col
    for(var i = 0; i < board.length; i++){
        var dupCheck = [];
        
        for(var j = 0; j < board[0].length; j++){
            if(board[i][j] !== '.' && dupCheck[board[i][j]]){
                return false;
            } else {
                dupCheck[board[i][j]] = true;
            }
        }
    }
    
    for(i = 0; i < board.length; i++){
        dupCheck = [];
        
        for(j = 0; j < board[0].length; j++){
            if(board[j][i] !== '.' && dupCheck[board[j][i]]){
                return false;
            } else {
                dupCheck[board[j][i]] = true;
            }
        }
    }
    
    for(i = 0; i < board.length; i+=3){
        for(j = 0; j < board.length; j+=3){
            dupCheck = [];
            
            for(var x = 0; x < 3; x++){
                for(var y = 0; y < 3; y++){
                    if(board[i+x][j+y] !== '.' && dupCheck[board[i+x][j+y]]){
                        return false;
                    } else {
                        dupCheck[board[i+x][j+y]] = true;
                    }
                }
            }
        }
    }
    
    return true;
  
  
    
};
</pre>
<hr />
</div>




<div>
<h3>104 Maximum Depth of Binary Tree</h3>
<a name="maxDepth"></a>
<pre>
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var maxDepth = function(root) {
  if(root === null){
      return 0;
  }  
  
  return 1+ Math.max(maxDepth(root.left), maxDepth(root.right));
};
</pre>
<hr />
</div>


<div>
<h3>112 Path Sum</h3>
<a name="pathSum"></a>
<pre>
// Leetcode #112 
// Language: Javascript
// Problem: https://leetcode.com/problems/path-sum/
// Author: Chihung Yu
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} sum
 * @return {boolean}
 */
var hasPathSum = function(root, sum) {
    if(root === null){
        return false;
    }
    
    if(root.val === sum && root.left === null && root.right === null){
        return true;
    }
    
    return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);
};
</pre>
<hr />
</div>

<div>
<h3>121 Best Time to Buy and Sell Stock</h3>
<a name="maxProfit"></a>
<pre>
// Say you have an array for which the ith element is the price of a given stock on day i.

// If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.

// Example 1:
// Input: [7, 1, 5, 3, 6, 4]
// Output: 5

// max. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price)
// Example 2:
// Input: [7, 6, 4, 3, 1]
// Output: 0

// In this case, no transaction is done, i.e. max profit = 0.
// Hide Company Tags Amazon Microsoft Bloomberg Uber Facebook
// Hide Tags Array Dynamic Programming
// Hide Similar Problems (M) Maximum Subarray (M) Best Time to Buy and Sell Stock II (H) Best Time to Buy and Sell Stock III (H) Best Time to Buy and Sell Stock IV (M) Best Time to Buy and Sell Stock with Cooldown

/**
 * @param {number[]} prices
 * @return {number}
 */
//  http://fisherlei.blogspot.com/2013/01/leetcode-best-time-to-buy-and-sell.html
var maxProfit = function(prices) {
    if(prices === null || prices.length === 0){
        return 0;
    }
    
    var max = 0;
    var diff = 0;
    var min = Infinity;
    
    for(var i = 0; i < prices.length; i++){
        var price = prices[i];
        if(min > price){
            min = price;
        }
        
        diff = price - min;
        
        if(max < diff){
            max = diff;
        }
    }
    
    return max;
};
</pre>
<hr />
</div>

<div>
<h3>122 Best Time to Buy and Sell Stock II</h3>
<a name="maxProfit2"></a>
<pre>
// Leetcode 122
// Language: Javascript
// Problem: https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/
// Author: Chihung Yu
/**
 * @param {number[]} prices
 * @return {number}
 */
var maxProfit = function(prices) {
    if(prices === null || prices.length === 0){
        return 0;
    }
    
    var profit = 0;

    for(var i = 1; i < prices.length; i++){
        var diff = prices[i] - prices[i-1];
        if(diff > 0){
            profit += diff;
        }
    }
    
    return profit;
};
</pre>
<hr />
</div>
<div>
<h3>123 Best Time to Buy and Sell Stock III</h3>
<a name=""></a>
<pre>
// Say you have an array for which the ith element is the price of a given stock on day i.

// Design an algorithm to find the maximum profit. You may complete at most two transactions.

// Note:
// You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).

// http://www.cnblogs.com/springfor/p/3877068.html

/**
 * @param {number[]} prices
 * @return {number}
 */
var maxProfit = function(prices) {
    // Calculate MaxProfit from 0 to x and MaxProfit from x + 1 to len - 1;
    var profitFromZeroToX = [];
    var profitFromXToEnd = [];
    var min = prices[0];

    // get max profit from 0 to x
    for(var x = 1; x < prices.length; x++) {
        var price = prices[x];
        min = Math.min(price, min);
        profitFromZeroToX[x] = Math.max(profitFromZeroToX[x - 1] || 0, price - min);
    }
    // get max profit from i + 1 to end
    var max = prices[prices.length - 1];
    for(x = prices.length - 2; x >= 0; x--) {
        price = prices[x];
        max = Math.max(price, max);
        profitFromXToEnd[x] = Math.max(profitFromXToEnd[x + 1] || 0, max - price);
    }
    
    var maxProfit = 0;
    for(x = 0; x < prices.length; x++) {
        var maxProfitSeperateAtX = (profitFromZeroToX[x] || 0) + (profitFromXToEnd[x] || 0);
        maxProfit = Math.max(maxProfitSeperateAtX, maxProfit);
    }
    
    return maxProfit;
};

</pre>
<hr />
</div>
<div>
<h3>125 Valid Palindrome</h3>
<a name="isPalindrome"></a>
<pre>
// Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.

// For example,
// "A man, a plan, a canal: Panama" is a palindrome.
// "race a car" is not a palindrome.

// Note:
// Have you consider that the string might be empty? This is a good question to ask during an interview.

// For the purpose of this problem, we define empty string as valid palindrome.

// Hide Company Tags Microsoft Uber Facebook Zenefits
// Hide Tags Two Pointers String
// Hide Similar Problems (E) Palindrome Linked List


/**
 * @param {string} s
 * @return {boolean}
 */
var isPalindrome = function(s) {
    s = s.toLowerCase();
    var beg = 0;
    var end = s.length - 1;
    
    while(beg < end) {
        if(!s[beg].match(/[a-z0-9]/)) {
            beg++;
        } else if(!s[end].match(/[a-z0-9]/)) {
            end--;
        } else if(s[beg] !== s[end]) {
            return false;
        } else {
            end--;
            beg++;
        }
    }
    
    return true;
};


/**
 * @param {string} s
 * @return {boolean}
 */
var isPalindrome = function(s) {
    var head = 0;
    var tail = s.length - 1;
    
    s = s.toLowerCase();
    
    while(head < tail) {
        while(s[head] && !s[head].match(/[a-z0-9]/)) {
            head++;
        }
        while(s[tail] && !s[tail].match(/[a-z0-9]/)) {
            tail--;
        }
        if(head < tail && s[head] !== s[tail]) {
            return false;
        }
        head++;
        tail--;
    }
    
    return true;
};
</pre>
<hr />
</div><div>
<h3>155 Min Stack</h3>
<a name="MinStack"></a>
<pre>
// Leetcode #155
// Language: Javascript
// Problem: https://leetcode.com/problems/min-stack/
// Author: Chihung Yu
/**
 * @constructor
 */
var MinStack = function() {
    this.min = [];
    this.stack = [];
}




/**
 * @param {number} x
 * @returns {void}
 */
MinStack.prototype.push = function(x) {
    var min = this.getMin();
    
    this.stack.push(x);
    
    if(min === undefined || min >= x){
        this.min.push(x);
    }
};

/**
 * @returns {void}
 */
MinStack.prototype.pop = function() {
    var val = this.stack.pop();
    var min = this.getMin();
    
    if(val === min){
        this.min.pop();
    }
};

/**
 * @returns {number}
 */
MinStack.prototype.top = function() {
    return this.stack[this.stack.length-1];
};

/**
 * @returns {number}
 */
MinStack.prototype.getMin = function() {
    return this.min[this.min.length - 1];
};
</pre>
<hr />
</div>
<div>
<h3>171 Excel Sheet Column Number</h3>
<a name="excelsheet"></a>
<pre>
// Leetcode #171
// Language: Javascript
// Problem: https://leetcode.com/problems/excel-sheet-column-number/
// Author: Chihung Yu
/**
 * @param {string} s
 * @return {number}
 */
var titleToNumber = function(s) {
    var total = 0;
    var len = s.length;
    var base = 26;
    
    for(var i = 0; i < len; i++){
        var pow = len - i - 1;
        var num = getNumber(s[i]);
        
        total += Math.pow(base,pow)*num;
    }
    
    return total;
};

var getNumber = function(c){
    var charCodeOfA = 'A'.charCodeAt(0);
    var charCodeOfTarget = c.charCodeAt(0);
    
    return charCodeOfTarget - charCodeOfA + 1;
};

</pre>
<hr />
</div>
<div>
<h3>202 Happy Number</h3>
<a name="isHappy"></a>
<pre>
// Leetcode #202
// Language: Javascript
// Problem: https://leetcode.com/problems/happy-number/
// Author: Chihung Yu
/**
 * @param {number} n
 * @return {boolean}
 */
var isHappy = function(n) {
    if(n === null){
        return false;
    }
    
    var val = n;
    var hash = {};
    
    while(!hash[val]){
        if(val === 1){
            return true;
        }
        
        hash[val] = true;
        
        var sn = val + '';
        var sarr = sn.split('');    
        var total = 0;
        
        for(var i = 0; i < sarr.length; i++){
            si = parseInt(sarr[i]);
            total += Math.pow(si,2);
        }
        
        
        val = total;
    }
    
    return false;
};
</pre>
<hr />
</div>

<div>
<h3>206 Reverse Linked List</h3>
<a name="reverseList"></a>
<pre>
// Leetcode #206
// Language: Javascript
// Problem: https://leetcode.com/problems/reverse-linked-list/
// Author: Chihung Yu


// Reverse a singly linked list.

// Uber Facebook Twitter Zenefits Amazon Microsoft Snapchat Apple Yahoo Bloomberg Yelp Adobe
// Show Tags
// Show Similar Problems

/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var reverseList = function(head) {
    var curr = head;
    var prev = null;
    
    while(curr) {
        var next = curr.next;
        curr.next = prev;
        prev = curr;
        curr = next; 
    }
    
    return prev;
};
</pre>
<hr />
</div>

<div>
<h3>242 Valid Anagram</h3>
<a name="isAnagram"></a>
<pre>
// Given two strings s and t, write a function to determine if t is an anagram of s.

// For example,
// s = "anagram", t = "nagaram", return true.
// s = "rat", t = "car", return false.



/**
 * @param {string} s
 * @param {string} t
 * @return {boolean}
 */
var isAnagram = function(s, t) {
   var slen = s.length;
   var tlen = t.length;
   
   if(slen !== tlen) {
       return false;
   }
   
   var hash = {};
   
   for(var i = 0; i < slen; i++) {
       var char = s[i];
       hash[char] = hash[char] || 0;
       hash[char]++;
   }
   
   for(i = 0; i < tlen; i++) {
       char = t[i];
       
       if(hash[char] === undefined || hash[char] === 0) {
           return false;
       }
       
       hash[char]--;
   }
   
   return true;
};
</pre>
<hr />
</div>

<div>
<h3>249 Group Shifted Strings</h3>
<a name="groupStrings"></a>
<pre>
// Given a string, we can "shift" each of its letter to its successive letter, for example: "abc" -> "bcd". We can keep "shifting" which forms the sequence:

// "abc" -> "bcd" -> ... -> "xyz"
// Given a list of strings which contains only lowercase alphabets, group all strings that belong to the same shifting sequence.

// For example, given: ["abc", "bcd", "acef", "xyz", "az", "ba", "a", "z"], 
// A solution is:

// [
//   ["abc","bcd","xyz"],
//   ["az","ba"],
//   ["acef"],
//   ["a","z"]
// ]
// reference: http://blog.csdn.net/pointbreak1/article/details/48780345

/**
 * @param {string[]} strings
 * @return {string[][]}
 */
var groupStrings = function(strings) {
    var result = [];
    var map = new Map();
    
    for(var i = 0; i < strings.length; i++) {
        var shift = '';
        var string = strings[i]
        for(var j = 0; j < string.length; j++) {
            shift += (string.charCodeAt(j) - string.charCodeAt(0) + 26)%26;
            shift += ' ';
        }
        if(map.has(shift)) {
            map.get(shift).push(string);
        } else {
            map.set(shift, [string]);
        }
    }

    map.forEach((value, key)=> {
        result.push(value);
    });
    
    
    return result;
};
</pre>
<hr />
</div>

<div>
<h3>266 Palindrome Permutation</h3>
<a name=""></a>
<pre>
// Given a string, determine if a permutation of the string could form a palindrome.

// For example,
// "code" -> False, "aab" -> True, "carerac" -> True.


/**
 * @param {string} s
 * @return {boolean}
 */
var canPermutePalindrome = function(s) {
    var countMap = {};
    
    for(var i = 0; i < s.length; i++) {
        var c = s[i];
        
        countMap[c] = countMap[c] || 0;
        countMap[c]++;
    }
    var oddCount = 0;
    
    for(i in countMap) {
        if(countMap[i]%2 === 1) {
            oddCount++;
        }
    }
    
    return oddCount < 2;
};

// Solution (2) that assume it's ascii 256 chars only

var canPermutePalindrome = function(s) {
    // assume that s is only contact 256 english letters
    var letters = Array(256).fill(0);
    var odd = 0;
    for(var i = 0; i < s.length; i++) {
        var letterIndex = s[i].charCodeAt(0);
        odd += (++letters[letterIndex] & 1) === 1 ? 1 : -1;
    }
    return odd < 2;
};
</pre>
<hr />
</div>

<div>
<h3>290 Word Pattern</h3>
<a name=""></a>
<pre>

</pre>
<hr />
</div>


<div>
<h3></h3>
<a name=""></a>
<pre>

</pre>
<hr />
</div>

<div>
<h3></h3>
<a name=""></a>
<pre>

</pre>
<hr />
</div>

<div>
<h3></h3>
<a name=""></a>
<pre>

</pre>
<hr />
</div>

<div>
<h3></h3>
<a name=""></a>
<pre>

</pre>
<hr />
</div>

<div>
<h3>Javascript Closure Questions</h3>
<a name="jsclosureaddquestion"></a>
<pre>
// implement function add in such a way that:
// add() => 0
// add(1)(2)() => 3
// add(n0)(n1)...(nk)() => n0+n1+...+nk

function add(val){
    var total = 0;
    var result;
    var step = function(val){
        if(val === undefined){
            result = total;
            total = 0;
            return result;
        } else {
            total += val;
        }
    
        return step;
    }
    
    result = step(val);
    
    return result;
}
</pre>
<hr />
</div>



<div>
<h3></h3>
<a name=""></a>
<pre>

</pre>
<hr />
</div>



</body>
</html>
